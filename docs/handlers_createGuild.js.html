<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Pronto: handlers/createGuild.js</title>
    
      <link type="text/css" rel="stylesheet" href="styles/vendor/prism-okaidia.css">
    
    <link type="text/css" rel="stylesheet" href="styles/styles.css">
    
    
    <style>
      :root {
      
      }
    </style>
    
</head>
<body>

<header class="layout-header">
  
  <h1>
    <a href="./index.html">
      Pronto
    </a>
  </h1>
  <nav class="layout-nav">
    <ul><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands.html">commands</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_approve.html">commands/approve</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_approve.html#~processMentions">processMentions</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_archive.html">commands/archive</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_assign.html">commands/assign</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_assign.html#~getUserInput">getUserInput</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_assign.html#~msgPrompt">msgPrompt</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_assign.html#~processMentions">processMentions</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_assign.html#~whileLoop">whileLoop</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_attendance.html">commands/attendance</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_connected.html">commands/connected</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_evaluate.html">commands/evaluate</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_evaluate.html#~convertToString">convertToString</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_evaluate.html#~findBreakIndex">findBreakIndex</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_evaluate.html#~removeSensitive">removeSensitive</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_help.html">commands/help</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_leave.html">commands/leave</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_leavefor.html">commands/leavefor</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_lesson.html">commands/lesson</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_lesson.html#~getNumberInput">getNumberInput</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_lesson.html#~processMentions">processMentions</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="module-commands_lesson.html#~serialiseResources">serialiseResources</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_ping.html">commands/ping</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_purge.html">commands/purge</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_restart.html">commands/restart</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_seen.html">commands/seen</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-commands_uptime.html">commands/uptime</a></span></li></ul><ul><li class="nav-heading">Namespaces</li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="commands.html">commands</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="config.html">config</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="handlers.html">handlers</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.commandLoader">commandLoader</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.createGuild">createGuild</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.database">database</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.permissionsCheck">permissionsCheck</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.upsertCommands">upsertCommands</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="models.html">models</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="modules.html">modules</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="pronto.html">pronto</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="pronto.html#.bot">bot</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="pronto.html#.version">version</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="pronto.html#~eventHandler">eventHandler</a></span></li></ul><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#createdChannels">createdChannels</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#currentlyCreating">currentlyCreating</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#pendingConfirmation">pendingConfirmation</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#pendingPromises">pendingPromises</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#recentlyAssigned">recentlyAssigned</a></span></li>
  </nav>
</header>


<main class="layout-main  layout-content--source">
  <div class="container">
    <p class="page-kind">source</p>
    <h1 class="page-title">handlers/createGuild.js</h1>
    



    

<section>
    <article>
        <pre id="source" class="source-page line-numbers"><code class="language-js">'use strict';

const Discord = require('discord.js');
// eslint-disable-next-line no-unused-vars
const Typings = require('../typings');
const mongoose = require('mongoose');

const { defaults, colours } = require('../config');
const { Guild } = require('../models');
const { debugError, sendMsg } = require('../modules');

/**
 * - Set to record the \&lt;Guild.id> snowflakes of the guild currently undergoing creation
 * - If a guild's snowflake is currently in this set, they must await until the Promises stored within the values of pendingPromises[\&lt;Guild.id>] resolve for the \&lt;Guild> document to be accessible
 * @type {Set&lt;Discord.Snowflake>}
 */
const currentlyCreating = new Set();

/**
 * - An \&lt;Object> to record all current pending Promises, stored as an \&lt;Object.\&lt;string, Promise\&lt;*>>> in the property pendingPromises[\&lt;Guild.id>]
 * - A guild's \&lt;Guild> document is only guaranteed to be accessible once all Promises within `Object.values(pendingPromises[&lt;Guild.id>])` have been resolved
 * @type {Object.&lt;string, Object.&lt;string, Promise&lt;*>>}
 */
const pendingPromises = {};

/**
 * A Collection\&lt;GuildChannel.Snowflake, Guild.Snowflake> to store any channels that have been created by Pronto as part of the current initialisation process(es)
 * @type {Discord.Collection&lt;Discord.Snowflake, Discord.Snowflake}
 */
const createdChannels = new Discord.Collection();

/**
 * `handlers.createGuild()` performs the initialisation process for a guild by creating/finding the default channels defined by `config.defaults`,
 * and creates and returns a new \&lt;Guild> document if it does not already exist
 * @function handlers.createGuild
 * @param {Discord.Guild} guild The guild to initialise
 * @returns {Promise&lt;Typings.Guild>} The guild's \&lt;Guild> document
 */
module.exports = async guild => {
	/**
	 * Attempt to find an existing \&lt;Guild> document by querying for the guild's identifer
	 * @type {?Typings.Guild}
	 */
	const existingDocument = await Guild.findOne({ guildID: guild.id }, error => {
		if (error) console.error(error);
	});

	// If the guild already has an existing &lt;Guild> document, return it and cease further execution
	if (existingDocument) return existingDocument;

	if (currentlyCreating.has(guild.id)) {
		// If the guild's identifier already exists inside the currentlyCreated set, await until the guild's pending Promises resolve for the &lt;Guild> document to be accessible
		await Promise.all(Object.values(pendingPromises[guild.id]));
		// Recursively call handlers.createGuild() to return the created &lt;Guild> document
		return await this(guild);
	}

	// Add the guild's identifier to the currentlyCreating set
	currentlyCreating.add(guild.id);

	const { bot } = require('../pronto');
	const { lessonInstructions, overwriteCommands } = require('./');

	// Call createGuildDocument() to create the guild's initial &lt;Guild> document, and wait for the document to be saved before proceeding
	// This is done by saving the Promise in an object within pendingPromises[guild.id], then waiting for that Promise to resolve
	pendingPromises[guild.id] = { createGuildDocument: createGuildDocument(guild) };
	await Promise.resolve(pendingPromises[guild.id].createGuildDocument);

	// Once the initial &lt;Guild> document has been created, call handlers.overwriteCommands() to upsert &lt;Guild.commands>, and save the Promise
	pendingPromises[guild.id].overwriteCommands = overwriteCommands(guild);
	await Promise.resolve(pendingPromises[guild.id].overwriteCommands);

	// Once the handlers.overwriteCommands() Promise has resolved, retrieve the complete &lt;Guild> document from its resolved value
	const guildDocument = pendingPromises[guild.id].overwriteCommands;

	// Remove the guild's identifier from the currentlyCreating set now that the &lt;Guild> document has been created
	currentlyCreating.delete(guild.id);

	// Call handlers.lessonInstructions() to send an instructional embed on Pronto's lesson management functionality
	lessonInstructions(guildDocument.ids.lessonReferenceID, guild);

	// If this guild has had some channels created as part of the initialisation process, send an embed listing the created channels
	if (createdChannels.some(guildID => guildID === guild.id)) {
		const { dateTimeGroup } = require('../modules');

		// Retrieve the &lt;CategoryChannel> that was created by Pronto to categorise Pronto's created channels
		const prontoCategory = bot.channels.cache.find(channel => channel.type === 'category' &amp;&amp; channel.name === defaults.pronto.name);
		// Get the guild's debug channel
		const debugChannel = bot.channels.cache.get(guildDocument.ids.debugID);

		// Create created channels embed
		const createdChannelsEmbed = new Discord.MessageEmbed()
			.setAuthor(bot.user.tag, bot.user.avatarURL({ dynamic: true }))
			.setColor(colours.primary)
			.setDescription(`Initialised channel(s) in **${prontoCategory}**, feel free to move and/or rename them!`)
			// Call channelsOutput() to format the guild's created channels into a
			.addField('Created Channels', channelsOutput(createdChannels, guildDocument))
			.addField('More Information', 'To modify my configuration, please visit my dashboard.')
			.setFooter(await dateTimeGroup());

		// Send the created channels embed
		sendMsg(debugChannel, { embeds: [createdChannelsEmbed] });
	}

	// Filter the createdChannels &lt;Collection> for channels created in this guild, and delete them from the &lt;Collection> now that we are done with them
	[...createdChannels.filter(guildID => guildID === guild.id).keys()]
		.forEach(channelID => createdChannels.delete(channelID));

	// Delete the guild's property from the pendingPromises &lt;Object> now that we are done with it
	delete pendingPromises[guild.id];

	// Return the created &lt;Guild> document
	return guildDocument;
};

/**
 * Creates an initial \&lt;Guild> document without a \&lt;Guild.commands> \&lt;BaseCommands> object, by calling `initialiseChannel()` and `findRole()` to populate the \&lt;Guild.ids> object
 * @function handlers.createGuild~createGuildDocument
 * @param {Discord.Guild} guild The guild to create a \&lt;Guild> document for
 * @returns {Promise&lt;Typings.Guild>} The created initial \&lt;Guild> document
 */
async function createGuildDocument(guild) {
	/**
	 * Create a new \&lt;Guild> document, by calling `initialiseChannel()` to find/create each necessary \&lt;GuildChannel>, and `findRole()` to find desired existing roles
	 * @type {Typings.Guild}
	 */
	const guildDocument = await new Guild({
		_id: mongoose.Types.ObjectId(),
		guildID: guild.id,
		guildName: guild.name,
		ids: {
			guildID: guild.id,
			debugID: await initialiseChannel(defaults.debug, guild),
			logID: await initialiseChannel(defaults.log, guild),
			attendanceID: await initialiseChannel(defaults.attendance, guild),
			recruitingID: await initialiseChannel(defaults.recruiting, guild),
			welcomeID: await initialiseChannel(defaults.welcome, guild),
			archivedID: await initialiseChannel(defaults.archived, guild, 'CATEGORY'),
			lessonsID: await initialiseChannel(defaults.lessons, guild, 'CATEGORY'),
			lessonReferenceID: await initialiseChannel(defaults.lessonReference, guild),
			lessonPlansID: await initialiseChannel(defaults.lessonPlans, guild),
			everyoneID: guild.roles.everyone.id,
			visitorID: findRole(defaults.visitor, guild),
		},
	});

	// Return the created initial &lt;Guild> document
	return await guildDocument.save().catch(error => console.error(error));
}

/**
 * Finds an existing \&lt;GuildChannel> that matches the specified \&lt;DefaultChannel.name>, or creates the channel if it does not already exist
 * @function handlers.createGuild~initialiseChannel
 * @param {Typings.DefaultChannel} defaultChannel The \&lt;DefaultChannel> object of the channel to find/create
 * @param {Discord.Guild} guild The guild to find/create the \&lt;GuildChannel> in
 * @param {?'TEXT' | 'CATEGORY'} type The type of the new channel, either `TEXT` || `CATEGORY`
 * - If `null`, a \&lt;TextChannel> will be created by default
 * @returns {Promise&lt;Discord.Snowflake>} The \&lt;GuildChannel.id> of the found/created channel
 */
async function initialiseChannel(defaultChannel, guild, type) {
	const { bot } = require('../pronto');

	/**
	 * A \&lt;PermissionString[]> of the minimum permissions Pronto must have in an existing `defaults.debug.name` \&lt;GuildChannel> to fully accept it as 'found', and to not create a new copy
	 * @type {Discord.PermissionString[]}
	 */
	const MINIMUM_PERMISSIONS = ['VIEW_CHANNEL', 'SEND_MESSAGES'];

	/**
	 * Test function to determine whether a \&lt;GuildChannel.name> matches the desired `defaultChannel.name`
	 * @param {Discord.GuildChannel} channel The \&lt;GuildChannel> to test
	 * @returns {boolean} Whether the \&lt;GuildChannel.name> matches the desired `defaultChannel.name`
	 */
	const matchesName = channel => channel.name === defaultChannel.name;

	/**
	 * Test function to determine whether Pronto has the minimum desired \&lt;Discord.Permissions> in the \&lt;GuildChannel>
	 * @param {Discord.GuildChannel} channel The \&lt;GuildChannel> to test
	 * @returns {boolean} Whether Pronto has the minimum desired \&lt;Discord.Permissions>, defined by `MINIMUM_PERMISSIONS`, in the specified \&lt;GuildChannel>
	 */
	const hasMinimumPermissions = channel => channel.permissionsFor(bot.user).has(MINIMUM_PERMISSIONS);

	// Attempt to first find a &lt;GuildChannel> that both matches the desired name and where Pronto has the minimum desired permissions, or if none was found, see if there a &lt;GuildChannel> that just matches the name
	const foundChannel = guild.channels.cache.find(channel => matchesName(channel) &amp;&amp; hasMinimumPermissions(channel)) || guild.channels.cache.find(matchesName);

	if (foundChannel) {
		// If a &lt;GuildChannel> was found, check whether the current initialiseChannel() call is searching for the guild's debugging channel, where Pronto must have the minimum permissions
		const findingDebugChannel = defaultChannel.name === defaults.debug.name;

		// As long as a &lt;GuildChannel> was found, return its &lt;GuildChannel.id>, unless the current initialiseChannel() call is for the guild's debugging channel and Pronto does not have the minimum permissions
		// If that is the case, ignore the found channel and continue execution to create a new debugging channel
		if (!findingDebugChannel || hasMinimumPermissions(foundChannel)) return foundChannel.id;
	}

	/**
	 * Test function to determine whether a
	 * @param {Discord.GuildChannel} channel
	 * @returns {boolean}
	 */
	const findProntoCategory = channel => channel.type === 'category' &amp;&amp; channel.name === defaults.pronto.name;

	let prontoCategory = guild.channels.cache.find(channel => findProntoCategory(channel) &amp;&amp; hasMinimumPermissions(channel));

	if (!prontoCategory) {
		await guild.channels.create(defaults.pronto.name, { type: 'category' })
			.then(async channel => {
				await channel.createOverwrite(bot.user.id, { 'VIEW_CHANNEL': true });
				channel.createOverwrite(guild.roles.everyone, { 'VIEW_CHANNEL': false });
				channel.setPosition(0);
				prontoCategory = channel;
			})
			.catch(error => debugError(error, `Error creating category '${defaults.pronto.name}' in ${guild.name}\n`));
	}

	const parent = (defaultChannel.parent)
		? guild.channels.cache.find(channel => channel.type === 'category' &amp;&amp; channel.name === defaultChannel.parent)
		: null;

	const channelOptions = (type === 'CATEGORY')
		? { type: type.toLowerCase() }
		: (parent)
			? { topic: defaultChannel.description, parent, type: type.toLowerCase() }
			: { topic: defaultChannel.description, parent: prontoCategory, type: type.toLowerCase() };

	const newChannel = await guild.channels.create(defaultChannel.name, channelOptions)
		.catch(error => debugError(error, `Error creating ${defaultChannel.name} in ${guild.name}\n`));

	createdChannels.set(newChannel.id, guild.id);

	if (foundChannel) {
		if (foundChannel.name === defaults.debug.name) {
			const debugEmbed = new Discord.MessageEmbed()
				.setColor(colours.error)
				.setDescription(`\n\nI created this channel because I cannot access ${foundChannel}!`);

			sendMsg(newChannel, { embeds: [debugEmbed] });
		}
	}

	return newChannel.id;
}

/**
 * Finds an existing \&lt;Role> that includes the specified name
 * @function handlers.createGuild~findRole
 * @param {string} name The \&lt;Role.name> of the role to search for
 * @param {Discord.Guild} guild The guild to search for the \&lt;Role> in
 * @returns {Discord.Snowflake | ''} The \&lt;Role.id> of the found role, or `''` if it was not found
 */
function findRole(name, guild) {
	// Attempt to find one &lt;Role.name> which contains the specified name as a substring, and return its identifier if found
	try { return guild.roles.cache.find(role => role.name.toLowerCase().includes(name.toLowerCase())).id; }
	// If no \&lt;Role> was found, simply return an empty string
	catch { return ''; }
}

/**
 * Process a Collection\&lt;GuildChannel.Snowflake, Guild.Snowflake> into a formatted string of channel mentions
 * @function handlers.createGuild~channelsOutput
 * @param {Discord.Collection&lt;Discord.Snowflake, Discord.Snowflake} collection A Collection\&lt;GuildChannel.Snowflake, Guild.Snowflake> that contains any channels that have been created as part of the current initialisation process(es)
 * @param {Discord.Guild} guild The guild to output a list of any created channel(s) for
 * @returns {string} A newline-delimited string of formatted channel mentions
 */
function channelsOutput(collection, guild) {
	// Filter the &lt;Collection> for channels created in the specified guild, then map each &lt;GuildChannel.Snowflake> to a new string[] of formatted mentions, and finally join the string[] with a newline separator
	return [...collection.filter(guildID => guildID === guild.id).keys()]
		.map(channel => `&lt;#${channel}>`)
		.join('\n');
}</code></pre>
    </article>
</section>




  </div>
</main>

<footer class="layout-footer">
  <div class="container">
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Dec 06 2021 17:13:19 GMT+1300 (New Zealand Daylight Time)
  </div>
</footer>



<script src="scripts/prism.dev.js"></script>
</body>
</html>
