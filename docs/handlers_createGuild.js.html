<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Pronto: handlers/createGuild.js</title>
    
      <link type="text/css" rel="stylesheet" href="styles/vendor/prism-okaidia.css">
    
    <link type="text/css" rel="stylesheet" href="styles/styles.css">
    
    
    <style>
      :root {
      
      }
    </style>
    
</head>
<body>

<header class="layout-header">
  
  <h1>
    <a href="./index.html">
      Pronto
    </a>
  </h1>
  <nav class="layout-nav">
    <ul><li class="nav-heading">Externals</li><li class="nav-heading"><span class="nav-item-type type-external" title="external">E</span><span class="nav-item-name is-external"><a href="external-Discord.html">Discord</a></span></li><li class="nav-heading"><span class="nav-item-type type-external" title="external">E</span><span class="nav-item-name is-external"><a href="external-mongoose.html">mongoose</a></span></li></ul><ul><li class="nav-heading">Namespaces</li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="commands.html">commands</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.approve">approve</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.archive">archive</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.assign">assign</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.attendance">attendance</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.connected">connected</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.evaluate">evaluate</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.help">help</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.leave">leave</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.leavefor">leavefor</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.lesson">lesson</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.ping">ping</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.purge">purge</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.restart">restart</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.seen">seen</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="commands.html#.uptime">uptime</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="config.html">config</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="events.html">events</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.exit">exit</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onBulkDelete">onBulkDelete</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onError">onError</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onGuildCreate">onGuildCreate</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onGuildDelete">onGuildDelete</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onMemberAdd">onMemberAdd</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onMemberBan">onMemberBan</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onMemberRemove">onMemberRemove</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onMemberUpdate">onMemberUpdate</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onMessage">onMessage</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onMessageDelete">onMessageDelete</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onMessageUpdate">onMessageUpdate</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onReactionAdd">onReactionAdd</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onReady">onReady</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onRoleInteraction">onRoleInteraction</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onRoleUpdate">onRoleUpdate</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="events.html#.onVoiceUpdate">onVoiceUpdate</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="handlers.html">handlers</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.createGuild">createGuild</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.database">database</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.permissionsCheck">permissionsCheck</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="handlers.html#.upsertCommands">upsertCommands</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="models.html">models</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="modules.html">modules</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="modules.html#.updatedPermissions">updatedPermissions</a></span></li><li class="nav-heading"><span class="nav-item-type type-namespace" title="namespace">N</span><span class="nav-item-name is-namespace"><a href="pronto.html">pronto</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="pronto.html#.bot">bot</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="pronto.html#.version">version</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="pronto.html#~eventHandler">eventHandler</a></span></li></ul>
  </nav>
</header>


<main class="layout-main  layout-content--source">
  <div class="container">
    <p class="page-kind">source</p>
    <h1 class="page-title">handlers/createGuild.js</h1>
    



    

<section>
    <article>
        <pre id="source" class="source-page line-numbers"><code class="language-js">'use strict';

const Discord = require('discord.js');
// eslint-disable-next-line no-unused-vars
const Typings = require('../typings');
const mongoose = require('mongoose');

const { defaults, colours } = require('../config');
const { Guild } = require('../models');
const { dateTimeGroup } = require('../modules');
const { debugError, lessonInstructions, overwriteCommands, sendMsg } = require('../handlers');

/**
 * - Set to record the \&lt;Guild.id> snowflakes of the guild currently undergoing creation
 * - If a guild's snowflake is currently in this set, they must await until the Promises stored within the values of pendingPromises[\&lt;Guild.id>] resolve for the \&lt;GuildConfiguration> document to be accessible
 * @type {Set&lt;Discord.Snowflake>}
 * @memberof handlers.createGuild
 */
const currentlyCreating = new Set();

/**
 * - An \&lt;Object> to record all current pending Promises, stored as an \&lt;Object.\&lt;string, Promise\&lt;*>>> in the property pendingPromises[\&lt;Guild.id>]
 * - A guild's \&lt;GuildConfiguration> document is only guaranteed to be accessible once all Promises within `Object.values(pendingPromises[&lt;Guild.id>])` have been resolved
 * @type {Object.&lt;string, Object.&lt;string, Promise&lt;*>>>}
 * @memberof handlers.createGuild
 */
const pendingPromises = {};

/**
 * A Collection\&lt;GuildChannel.Snowflake, Guild.Snowflake> to store any channels that have been created by Pronto as part of the current initialisation process(es)
 * @type {Discord.Collection&lt;Discord.Snowflake, Discord.Snowflake>}
 * @memberof handlers.createGuild
 */
const createdChannels = new Discord.Collection();

/**
 * `handlers.createGuild()` performs the initialisation process for a guild by creating/finding the default channels defined by [`config.defaults`]{@link config.Configuration},
 * and creates and returns a new \&lt;GuildConfiguration> document if it does not already exist
 * @function handlers.createGuild
 * @param {Discord.Guild} guild The \&lt;Guild> to initialise
 * @returns {Promise&lt;Typings.GuildConfiguration>} The guild's \&lt;GuildConfiguration> document
 */
module.exports = async guild => {
	/**
	 * Attempt to find an existing \&lt;GuildConfiguration> document by querying for the guild's identifer
	 * @type {?Typings.GuildConfiguration}
	 */
	const existingDocument = await Guild.findOne({ guildID: guild.id }, error => {
		if (error) console.error(error);
	});

	// If the guild already has an existing &lt;GuildConfiguration> document, return it and cease further execution
	if (existingDocument) return existingDocument;

	if (currentlyCreating.has(guild.id)) {
		// If the guild's identifier already exists inside the currentlyCreated set, await until the guild's pending Promises resolve for the &lt;GuildConfiguration> document to be accessible
		await Promise.all(Object.values(pendingPromises[guild.id]));
		// Recursively call handlers.createGuild() to return the created &lt;GuildConfiguration> document
		return await this(guild);
	}

	// Add the guild's identifier to the currentlyCreating set
	currentlyCreating.add(guild.id);

	const { bot } = require('../pronto');

	// Call createGuildDocument() to create the guild's initial Partial&lt;GuildConfiguration> document, and wait for the document to be saved before proceeding
	// This is done by saving the Promise in an object within pendingPromises[guild.id], then waiting for that Promise to resolve
	pendingPromises[guild.id] = { createGuildDocument: createGuildDocument(guild) };
	await Promise.resolve(pendingPromises[guild.id].createGuildDocument);

	// Once the initial Partial&lt;GuildConfiguration> document has been created, call handlers.overwriteCommands() to upsert &lt;GuildConfiguration.commands>, and save the Promise
	pendingPromises[guild.id].overwriteCommands = overwriteCommands(guild);
	await Promise.resolve(pendingPromises[guild.id].overwriteCommands);

	// Once the handlers.overwriteCommands() Promise has resolved, retrieve the complete &lt;GuildConfiguration> document from its resolved value
	const guildDocument = pendingPromises[guild.id].overwriteCommands;

	// Remove the guild's identifier from the currentlyCreating set now that the &lt;GuildConfiguration> document has been created
	currentlyCreating.delete(guild.id);

	// Call handlers.lessonInstructions() to send an instructional embed on Pronto's lesson management functionality
	lessonInstructions(guildDocument.ids.lessonReferenceID, guild);

	// If this guild has had some channels created as part of the initialisation process, send an embed listing the created channels
	if (createdChannels.some(guildID => guildID === guild.id)) {
		// Retrieve the &lt;CategoryChannel> that was created by Pronto to categorise Pronto's created channels
		const prontoCategory = bot.channels.cache.find(channel => channel.type === 'category' &amp;&amp; channel.name === defaults.pronto.name);
		// Get the guild's debug channel
		const debugChannel = bot.channels.cache.get(guildDocument.ids.debugID);

		// Create created channels embed
		const createdChannelsEmbed = new Discord.MessageEmbed()
			.setAuthor(bot.user.tag, bot.user.avatarURL({ dynamic: true }))
			.setColor(colours.primary)
			.setDescription(`Initialised channel(s) in **${prontoCategory}**, feel free to move and/or rename them!`)
			// Call channelsOutput() to format the guild's created channels into a
			.addField('Created Channels', channelsOutput(createdChannels, guildDocument))
			.addField('More Information', 'To modify my configuration, please visit my dashboard.')
			.setFooter(await dateTimeGroup());

		// Send the created channels embed
		sendMsg(debugChannel, { embeds: [createdChannelsEmbed] });
	}

	// Filter the createdChannels &lt;Collection> for channels created in this guild, and delete them from the &lt;Collection> now that we are done with them
	[...createdChannels.filter(guildID => guildID === guild.id).keys()]
		.forEach(channelID => createdChannels.delete(channelID));

	// Delete the guild's property from the pendingPromises &lt;Object> now that we are done with it
	delete pendingPromises[guild.id];

	// Return the created &lt;GuildConfiguration> document
	return guildDocument;
};

/**
 * Creates an initial Partial\&lt;GuildConfiguration> without a \&lt;GuildConfiguration.commands> \&lt;BaseCommands> object, by calling `initialiseChannel()` and `findRole()` to populate the \&lt;GuildConfiguration.ids> object
 * @function handlers.createGuild~createGuildDocument
 * @param {Discord.Guild} guild The \&lt;Guild> to create a \&lt;GuildConfiguration> document for
 * @returns {Promise&lt;Typings.GuildConfiguration>} The created initial \&lt;GuildConfiguration> document
 */
async function createGuildDocument(guild) {
	/**
	 * Create a new \&lt;GuildConfiguration> document, by calling `initialiseChannel()` to find/create each necessary \&lt;GuildChannel>, and `findRole()` to find desired existing roles
	 * @type {Typings.GuildConfiguration}
	 */
	const guildDocument = await new Guild({
		_id: mongoose.Types.ObjectId(),
		guildID: guild.id,
		guildName: guild.name,
		ids: {
			guildID: guild.id,
			debugID: await initialiseChannel(defaults.debug, guild),
			logID: await initialiseChannel(defaults.log, guild),
			attendanceID: await initialiseChannel(defaults.attendance, guild),
			recruitingID: await initialiseChannel(defaults.recruiting, guild),
			welcomeID: await initialiseChannel(defaults.welcome, guild),
			archivedID: await initialiseChannel(defaults.archived, guild),
			lessonsID: await initialiseChannel(defaults.lessons, guild),
			lessonReferenceID: await initialiseChannel(defaults.lessonReference, guild),
			lessonPlansID: await initialiseChannel(defaults.lessonPlans, guild),
			everyoneID: guild.roles.everyone.id,
			visitorID: findRole(defaults.visitor, guild),
		},
	});

	// Return the created initial &lt;GuildConfiguration> document
	return await guildDocument.save().catch(error => console.error(error));
}

/**
 * Finds an existing \&lt;GuildChannel> that matches the specified \&lt;DefaultChannel.name>, or creates the channel if it does not already exist
 * @function handlers.createGuild~initialiseChannel
 * @param {Typings.DefaultChannel} defaultChannel The \&lt;DefaultChannel> object of the channel to find/create
 * @param {Discord.Guild} guild The \&lt;Guild> to find/create the \&lt;GuildChannel> in
 * @returns {Promise&lt;Discord.Snowflake>} The \&lt;GuildChannel.id> of the found/created channel
 */
async function initialiseChannel(defaultChannel, guild) {
	const { bot } = require('../pronto');

	/**
	 * A \&lt;PermissionString[]> of the minimum permissions Pronto must have in an existing [`config.defaults.debug.name`]{@link config.Configuration} \&lt;GuildChannel> to fully accept it as 'found', and to not create a new copy
	 * @type {Discord.PermissionString[]}
	 */
	const MINIMUM_PERMISSIONS = ['VIEW_CHANNEL', 'SEND_MESSAGES'];

	/**
	 * Test function to determine whether a \&lt;GuildChannel.name> matches the desired `defaultChannel.name`
	 * @param {Discord.GuildChannel} channel The \&lt;GuildChannel> to test
	 * @returns {boolean} Whether the \&lt;GuildChannel.name> matches the desired `defaultChannel.name`
	 */
	const matchesName = channel => channel.name === defaultChannel.name;

	/**
	 * Test function to determine whether Pronto has the minimum desired \&lt;Discord.Permissions> in the \&lt;GuildChannel>
	 * @param {Discord.GuildChannel} channel The \&lt;GuildChannel> to test
	 * @returns {boolean} Whether Pronto has the minimum desired \&lt;Discord.Permissions>, defined by `MINIMUM_PERMISSIONS`, in the specified \&lt;GuildChannel>
	 */
	const hasMinimumPermissions = channel => channel.permissionsFor(bot.user).has(MINIMUM_PERMISSIONS);

	// Attempt to first find a &lt;GuildChannel> that both matches the desired name and where Pronto has the minimum desired permissions, or if none was found, see if there a &lt;GuildChannel> that just matches the name
	const foundChannel = guild.channels.cache.find(channel => matchesName(channel) &amp;&amp; hasMinimumPermissions(channel)) || guild.channels.cache.find(matchesName);

	if (foundChannel) {
		// If a &lt;GuildChannel> was found, check whether the current initialiseChannel() call is searching for the guild's debugging channel, where Pronto must have the minimum permissions
		const findingDebugChannel = defaultChannel.name === defaults.debug.name;

		// As long as a &lt;GuildChannel> was found, return its &lt;GuildChannel.id>, unless the current initialiseChannel() call is for the guild's debugging channel and Pronto does not have the minimum permissions
		// If that is the case, ignore the found channel and continue execution to create a new debugging channel
		if (!findingDebugChannel || hasMinimumPermissions(foundChannel)) return foundChannel.id;
	}

	/**
	 * Test function to find a \&lt;CategoryChannel> whose name matches the name defined by [`config.defaults.pronto.name`]{@link config.Configuration}
	 * @param {Discord.GuildChannel} channel The \&lt;GuildChannel> to test
	 * @returns {boolean} Whether the \&lt;GuildChannel> is a \&lt;CategoryChannel> whose name matches [`config.defaults.pronto.name`]{@link config.Configuration}
	 */
	const findProntoCategory = channel => channel.type === 'category' &amp;&amp; channel.name === defaults.pronto.name;

	// Attempt to find a &lt;GuildChannel> that matches the name of the Pronto category channel defined by config.defaults.pronto.name, and where Pronto has the minimum desired permissions
	let prontoCategory = guild.channels.cache.find(channel => findProntoCategory(channel) &amp;&amp; hasMinimumPermissions(channel));

	if (!prontoCategory) {
		// If the Pronto category channel could not be found, create it for the guild
		await guild.channels.create(defaults.pronto.name, { type: 'category' })
			.then(async channel => {
				// Ensure the bot has VIEW_CHANNEL permissions before hiding the channel for @everyone
				await channel.createOverwrite(bot.user.id, { 'VIEW_CHANNEL': true });
				// Make the created &lt;CategoryChannel> hidden for @everyone
				channel.createOverwrite(guild.roles.everyone, { 'VIEW_CHANNEL': false });
				// Move the created &lt;CategoryChannel> to the top of the channels list
				channel.setPosition(0);

				// Store the created &lt;CategoryChannel> in the prontoCategory variable
				prontoCategory = channel;
			})
			.catch(error => debugError(error, `Error creating category '${defaults.pronto.name}' in ${guild.name}\n`));
	}

	// If the channel to be created must be created within a specific category, attempt to find it
	const parent = (defaultChannel.parent)
		? guild.channels.cache.find(channel => channel.type === 'category' &amp;&amp; channel.name === defaultChannel.parent)
		: null;

	/**
	 * The dynamically-set \&lt;GuildChannelCreateOptions> for the \&lt;GuildChannel> to create
	 * @type {Discord.GuildChannelCreateOptions}
	 */
	const channelOptions = (defaultChannel.type === 'CATEGORY')
		// If the type of the channel to be created is a &lt;CategoryChannel>, set the &lt;GuildChannelCreateOptions> accordingly
		? { type: defaultChannel.type.toLowerCase() }
		: (parent)
			// Otherwise, if the channel to be created is not a &lt;CategoryChannel> but has a specific parent, set the options accordingly
			? { topic: defaultChannel.description, parent, type: defaultChannel.type.toLowerCase() }
			// Otherwise, create the &lt;GuildChannel> within the prontoCategory &lt;CategoryChannel>
			: { topic: defaultChannel.description, parent: prontoCategory, type: defaultChannel.type.toLowerCase() };

	// Create the &lt;GuildChannel>, using the specified name and appropriate &lt;GuildChannelCreateOptions>
	const createdChannel = await guild.channels.create(defaultChannel.name, channelOptions)
		.catch(error => debugError(error, `Error creating ${defaultChannel.name} in ${guild.name}\n`));

	// Record the identifier of the created &lt;GuildChannel> and its &lt;Guild.id> within the createdChannels &lt;Collection>
	createdChannels.set(createdChannel.id, guild.id);

	if (foundChannel) {
		// If the existing debugging channel could not be accessed by Pronto, create and send an embed to the created debugging channel to communicate that
		const debugEmbed = new Discord.MessageEmbed()
			.setColor(colours.error)
			.setDescription(`\n\nI created this channel because I cannot access ${foundChannel}!`);

		sendMsg(createdChannel, { embeds: [debugEmbed] });
	}

	// Return the identifier of the created &lt;GuildChannel>
	return createdChannel.id;
}

/**
 * Finds an existing \&lt;Role> that includes the specified name
 * @function handlers.createGuild~findRole
 * @param {Typings.DefaultRole} defaultRole The \&lt;Role.name> of the role to search for
 * @param {Discord.Guild} guild The \&lt;Guild> to search for the \&lt;Role> in
 * @returns {Discord.Snowflake | ''} The \&lt;Role.id> of the found role, or `''` if it was not found
 */
function findRole(defaultRole, guild) {
	// Attempt to find one &lt;Role.name> which contains the specified name as a substring, and return its identifier if found
	try { return guild.roles.cache.find(role => role.name.toLowerCase().includes(defaultRole.name.toLowerCase())).id; }
	// If no \&lt;Role> was found, simply return an empty string
	catch { return ''; }
}

/**
 * Process a Collection\&lt;GuildChannel.Snowflake, Guild.Snowflake> into a formatted string of channel mentions
 * @function handlers.createGuild~channelsOutput
 * @param {Discord.Collection&lt;Discord.Snowflake, Discord.Snowflake>} collection A Collection\&lt;GuildChannel.Snowflake, Guild.Snowflake> that contains any channels that have been created as part of the current initialisation process(es)
 * @param {Discord.Guild} guild The \&lt;Guild> to output a list of any created channel(s) for
 * @returns {string} A newline-delimited string of formatted channel mentions
 */
function channelsOutput(collection, guild) {
	// Filter the &lt;Collection> for channels created in the specified guild, then map each &lt;GuildChannel.Snowflake> to a new string[] of formatted mentions, and finally join the string[] with a newline separator
	return [...collection.filter(guildID => guildID === guild.id).keys()]
		.map(channel => `&lt;#${channel}>`)
		.join('\n');
}</code></pre>
    </article>
</section>




  </div>
</main>

<footer class="layout-footer">
  <div class="container">
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Dec 08 2021 18:23:02 GMT+1300 (New Zealand Daylight Time)
  </div>
</footer>



<script src="scripts/prism.dev.js"></script>
</body>
</html>
